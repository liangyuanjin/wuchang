---
title: Golang 程序结构
date: 2021-04-15 08:41:38
tags: Go
categories: Go
description: Golang 环境搭建
top_img: https://cdn.pixabay.com/photo/2021/01/05/06/40/boat-5889919_1280.png
cover: /images/golang/golang-framework-choose.jpeg
---

> Go 和其他语言一样，程序是由很多小的基础构件组成的，变量存值，简单的加法和减法运算被组合成复杂的表达式，还有基础类型被聚合为数组或结构体，后面这些都会一一学习到，先从最简单的 `命令`, `声明`, `变量`, `赋值`，`类型`, `包和文件`, `作用域`这些基础的概念学习

## 命名

---

> 在 Go 中`函数名`, `变量名`, `常量名`, `类型名`, `语句标识`和`包名`, 遵循的规则为 `一个名字必须以一个字母或下划线开头，后面可以跟任意数量的字母，数字或下划线`, `严格区分大小写`。

### 关键字

> Go 的关键字并不是很多，有`25个`, 关键字`不能用于自定义的名字`,在特定的语法结构中使用

```GO
break      default       func      interface     select
case       defer         go        map           struct
chan       else          goto      package       switch
const      fallthrough   if        range         type
continue   for           import    return        var
```

### 预定义名字

> `预定义名字并不是关键字`,可以在定义中重新使用他们, 但是要要注意`避免过度使用而引起的语义混乱`, 在Go 中这样的预定义名字大约有 30 多个， 主要对应 `内建的常量`, `类型` 和 `函数`

```go
// 内建常量:
            true  false  iota  nil
// 内建类型:
            int      int8      int16       int32      int64
            uint     uint8     uint16      uint32     uint64
            float32  float64   complex128  complex64  uintptr
            bool     byte      rune        string     error
// 内建函数:
            make    len     cap   new   append   copy   close   delete
            complex real    imag
            panic   recover
```

### 命名推荐

> 名字出现的位置, 影响到这个名字的有效使用范围，和作用域有关系，作用域这个后面会有讲到,名字在`函数内部定义, 就只在函数内部有效`,在 `函数外部定义, 当前包的所有文件中都可以访问`, `名字的开头字母的大小决定了包外的可见性`, `大写字母开头,是可以导出的, 可以被外部访问`, `包名`采用`小写字母`, Go语言名字的风格推荐`短小的名字`, `驼峰式命名`, `多个单词单用大小写分割`

## 声明

---

> Go语言主要有四种类型声明的语句: `var`,`const`, `type` 和 `func`, 分别对应 `变量`, `常量`, `类型`, `函数实体对象`, 一个 `Go` 语言程序对应一个或多个`.go` 为文件后缀名的源文件中，每个源文件`以包的声明语句开始，说明该源文件属于那个包`

```go
package main

import "fmt"

const boilingF = 212.0

func main() {
    var f = boilingF
    var c = (f - 32) * 8 / 9
    fmt.Printf("boiling point = %g°F or %g°C \n", f, c)
}
```

* `import` import语句导入依赖的其它包
* `boilingF` 变量是包一级声明语句声明, 可以在`整个包对应的每个源文件中被访问`
* `f`和`c` 变量是函数内部声明, 只能在`函数内部被访问`

## 变量

---

> `var` 声明语句可以`创建特定类型的变量`, 给变量附加一个名字，并且设置变量的初始值

`语法格式`

```go
var 变量名字  类型 = 表达式
```

* `表达式` 和 `类型` 两个可以省略一个, 省略`类型信息`, 将根据初始化表达式推导变量的类型信息, 省略 `表达式`, 将用 `零值` 初始化该变量, 这里要注意的是 `接口`或`引用类型(包括 slice, 指针, map chan 和 函数)` 变量对应的零值是 `nil`, 这样做的好处是 `可以确保每个声明的变量总有一个良好定义的值`, `Go语言中不存在未初始化的变量`。

```go
var s string
fmt.Println(s) // ""
```

同时声明多个变量

```go
var i, j, k int // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

### 简短变量

> `简短变量`声明语句的形式可用于声明和初始化局部变量, 形式为 `名字 := 表达式`, 变量的类型根据表达式来自动推导,多用与局部变量的声明和初始化，`var` 声明语句多用于需要`显示指定变量类型的地方`, `:=` 是一个变量声明语句，`=` 是一个变量赋值操作。

```go
t := 0.0
freq := rand.Float64() * 3.0
i, j := 0, 1
```

`:=是一个变量声明语句`

```go
i, j = j, i //交换i和j的值
```

> `简短变量` 声明左边的变量可能并不是全部都是刚刚声明的，如果有一些已经在`相同的作用域`声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为, `简短变量声明语句中至少要声明一个新的变量`, 如果`不在同一作用域中`，那么简短变量将会`在当前作用域声明一个新的变量`

```go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

## 指针

---

> `变量对应一个保存了变量对应类型值的内存空间`, 普通变量在声明语句创建时被绑定到一个变量名, 还有很多变量是用表达式引入的， `x[i]` 或 `x.f` 变量, 所有这些表达式一般都是读取一个变量的值。`一个指针的值是另一个变量的地址, 一个指针对应变量在内存中的存储位置`, 并不是每个值都会有一个内存地址，但每一个变量都会有对应的内存地址，`通过指针我们可以直接读或更新对应变量的值，而不需要知道该变量的名字`

```go

    x := 1
    p := &x
    fmt.Println(*p)
    *p = 4
    fmt.Println(x)
}
```

> 声明 `x` 变量, `&x` 表达式将产生一个指向该整数变量的指针, 指针对应的类型为 `*int`, 指针名为`p`, 那么可以说`p`指针指向变量 `x`, `*p` 表达式对应p指针指向的变量的值，`*p`表达式读取指针指向变量的值

`聚合类型`

> `聚合类型`， 比如`结构体的每个字段`，或者`数组的每个元素`，也都是对应一个变量，所以可以被取地址，变量有时被称为可寻址的值，`即使变量由表达式临时生成，那么表达式也必须能接受 & 取地址操作`,`任何类型的指针零值都是 nil`。